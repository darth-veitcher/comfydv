{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"comfydv","text":"<p>A collection of workflow efficiency and quality of life nodes that I've created for personal use out of necessity.</p> <ul> <li>String Formatting: Use either plain python f-strings or more advanced Jinja2 templating to format outputs.</li> <li>Random Choice: Add an abitrary number of inputs and then, with seed control, randomly select one for an output.</li> </ul>"},{"location":"#string-formatting","title":"String Formatting","text":""},{"location":"#python-f-string","title":"Python F-String","text":"<p>A simple python f-string dynamically creates the necessary inputs/outputs for the detected keys.</p> <p></p>"},{"location":"#jinja-2","title":"Jinja 2","text":"<p>Switching to Jinja2 allows you to use more advanced control blocks and other filters/features of that templating language. See Jinja documentation for further details.</p> <p></p>"},{"location":"#random-choice","title":"Random Choice","text":"<p>Ability to take arbitrary length and type of inputs to then output a choice with a controllable seed.</p> <p></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>comfydv<ul> <li>circuit_breaker</li> <li>format_string</li> <li>model_unload</li> <li>random_choice</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/comfydv/","title":"comfydv","text":""},{"location":"reference/comfydv/circuit_breaker/","title":"circuit_breaker","text":"<p>This node is designed in a hacky way to allow you to break a render run semi-gracefully.</p>"},{"location":"reference/comfydv/circuit_breaker/#comfydv.circuit_breaker.CircuitBreaker","title":"<code>CircuitBreaker</code>","text":"Source code in <code>src/comfydv/circuit_breaker.py</code> <pre><code>class CircuitBreaker:\n    def __init__(self):\n        pass\n\n    @classmethod\n    def INPUT_TYPES(s):\n        \"\"\"\n        Return a dictionary which contains config for all input fields.\n        Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\".\n        Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node.\n        The type can be a list for selection.\n\n        Returns: `dict`:\n            - Key input_fields_group (`string`): Can be either required, hidden or optional. A node class must have property `required`\n            - Value input_fields (`dict`): Contains input fields config:\n                * Key field_name (`string`): Name of a entry-point method's argument\n                * Value field_config (`tuple`):\n                    + First value is a string indicate the type of field or a list for selection.\n                    + Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".\n        \"\"\"\n        return {\n            \"required\": {\"trigger\": (\"IMAGE\", {})},\n            \"optional\": {\"status\": (\"BOOLEAN\", {\"default\": True})},\n        }\n\n    RETURN_TYPES = (\"IMAGE\",)\n    RETURN_NAMES = (\"passthrough\",)\n\n    FUNCTION = \"doit\"\n\n    OUTPUT_NODE = True\n\n    CATEGORY = \"dv/utils\"\n\n    def doit(self, trigger, **kwargs):\n        if kwargs.get(\"status\"):\n            print(f\"Circuit Breaker triggered\")\n            raise InterruptProcessingException()\n        else:\n            return (trigger,)\n</code></pre>"},{"location":"reference/comfydv/circuit_breaker/#comfydv.circuit_breaker.CircuitBreaker.INPUT_TYPES","title":"<code>INPUT_TYPES(s)</code>  <code>classmethod</code>","text":"<p>Return a dictionary which contains config for all input fields. Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\". Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node. The type can be a list for selection.</p> <p>`dict`:</p> Type Description <ul> <li>Key input_fields_group (<code>string</code>): Can be either required, hidden or optional. A node class must have property <code>required</code></li> </ul> <ul> <li>Value input_fields (<code>dict</code>): Contains input fields config:</li> <li>Key field_name (<code>string</code>): Name of a entry-point method's argument</li> <li>Value field_config (<code>tuple</code>):<ul> <li>First value is a string indicate the type of field or a list for selection.</li> <li>Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".</li> </ul> </li> </ul> Source code in <code>src/comfydv/circuit_breaker.py</code> <pre><code>@classmethod\ndef INPUT_TYPES(s):\n    \"\"\"\n    Return a dictionary which contains config for all input fields.\n    Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\".\n    Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node.\n    The type can be a list for selection.\n\n    Returns: `dict`:\n        - Key input_fields_group (`string`): Can be either required, hidden or optional. A node class must have property `required`\n        - Value input_fields (`dict`): Contains input fields config:\n            * Key field_name (`string`): Name of a entry-point method's argument\n            * Value field_config (`tuple`):\n                + First value is a string indicate the type of field or a list for selection.\n                + Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".\n    \"\"\"\n    return {\n        \"required\": {\"trigger\": (\"IMAGE\", {})},\n        \"optional\": {\"status\": (\"BOOLEAN\", {\"default\": True})},\n    }\n</code></pre>"},{"location":"reference/comfydv/format_string/","title":"format_string","text":"<p>FormatString module for ComfyUI.</p> <p>This module provides a custom node for ComfyUI that allows formatting strings using either simple Python formatting or Jinja2 templates. It can also save formatted templates to disk for later reuse.</p> <p>The node dynamically updates its inputs and outputs based on the variables detected in the template, making it highly flexible for various text generation and parameter formatting needs in ComfyUI workflows.</p>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString","title":"<code>FormatString</code>","text":"<p>A ComfyUI node for string formatting using Python's format syntax or Jinja2 templates.</p> <p>This node dynamically adapts its inputs and outputs based on the variables detected in the provided template. It supports saving template state to disk and loading it back. The node can operate in two modes: 1. Simple: Uses Python's str.format() method 2. Jinja2: Uses Jinja2 templating engine with sandbox protection</p> <p>Additional context variables like datetime, random, and math functions are available in Jinja2 mode.</p> <p>Attributes:</p> Name Type Description <code>CATEGORY</code> <code>str</code> <p>The category of the node in ComfyUI's node menu.</p> <code>FUNCTION</code> <code>str</code> <p>The main function to be called when the node is executed.</p> <code>RETURN_TYPES</code> <code>tuple</code> <p>Types of the returned outputs.</p> <code>RETURN_NAMES</code> <code>tuple</code> <p>Names of the returned outputs.</p> <code>node_configs</code> <code>dict</code> <p>Storage for configurations of node instances.</p> <code>jinja_env</code> <code>SandboxedEnvironment</code> <p>Sandboxed Jinja2 environment for secure template rendering.</p> <code>additional_context</code> <code>dict</code> <p>Extra context variables available in Jinja2 templates.</p> Source code in <code>src/comfydv/format_string.py</code> <pre><code>class FormatString:\n    \"\"\"\n    A ComfyUI node for string formatting using Python's format syntax or Jinja2 templates.\n\n    This node dynamically adapts its inputs and outputs based on the variables detected\n    in the provided template. It supports saving template state to disk and loading it back.\n    The node can operate in two modes:\n    1. Simple: Uses Python's str.format() method\n    2. Jinja2: Uses Jinja2 templating engine with sandbox protection\n\n    Additional context variables like datetime, random, and math functions are available\n    in Jinja2 mode.\n\n    Attributes:\n        CATEGORY (str): The category of the node in ComfyUI's node menu.\n        FUNCTION (str): The main function to be called when the node is executed.\n        RETURN_TYPES (tuple): Types of the returned outputs.\n        RETURN_NAMES (tuple): Names of the returned outputs.\n        node_configs (dict): Storage for configurations of node instances.\n        jinja_env (SandboxedEnvironment): Sandboxed Jinja2 environment for secure template rendering.\n        additional_context (dict): Extra context variables available in Jinja2 templates.\n    \"\"\"\n\n    CATEGORY = \"dv/string_operations\"\n    FUNCTION = \"format_string\"\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n    RETURN_NAMES = (\"formatted_string\", \"saved_file_path\")\n\n    # Store configurations for each node instance\n    node_configs = {}\n\n    # Create a sandboxed Jinja2 environment for security\n    jinja_env = sandbox.SandboxedEnvironment()\n\n    # Define additional context\n    def time_now() -&gt; str:\n        \"\"\"\n        Get the current time in a formatted string.\n\n        Returns:\n            str: Current time formatted as 'YYYYMMDD-HHMMSS'.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            timestamp = FormatString.time_now()\n            print(timestamp)  # Outputs something like: '20240327-153045'\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; timestamp = FormatString.time_now()\n        &gt;&gt;&gt; assert len(timestamp) == 15  # Format YYYYMMDD-HHMMSS is 15 chars\n        &gt;&gt;&gt; assert timestamp[8] == '-'  # Check format separator\n        &gt;&gt;&gt; # Verify it's roughly the current time (allowing some seconds of delay)\n        &gt;&gt;&gt; current = datetime.now().strftime(\"%Y%m%d-%H%M\")\n        &gt;&gt;&gt; assert timestamp.startswith(current)\n        --&gt;\n        \"\"\"\n        return datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n\n    additional_context = {\n        \"datetime\": datetime,\n        \"now\": time_now,\n        \"random\": random,\n        \"math\": math,\n        # Add more modules or functions as needed\n    }\n\n    @classmethod\n    def INPUT_TYPES(cls) -&gt; Dict[str, Any]:\n        \"\"\"\n        Define the input types for the FormatString node.\n\n        This method is called by ComfyUI to determine what inputs the node should have.\n\n        Returns:\n            Dict[str, Any]: Dictionary defining the node's inputs, including template_type,\n                           template, save_path, and a hidden unique_id.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            input_types = FormatString.INPUT_TYPES()\n            print(input_types[\"required\"][\"template_type\"])  # Outputs: ([\"Simple\", \"Jinja2\"],)\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; input_types = FormatString.INPUT_TYPES()\n        &gt;&gt;&gt; assert \"required\" in input_types\n        &gt;&gt;&gt; assert \"template_type\" in input_types[\"required\"]\n        &gt;&gt;&gt; assert \"template\" in input_types[\"required\"]\n        &gt;&gt;&gt; assert \"save_path\" in input_types[\"required\"]\n        &gt;&gt;&gt; assert \"hidden\" in input_types\n        &gt;&gt;&gt; assert \"unique_id\" in input_types[\"hidden\"]\n        &gt;&gt;&gt; assert input_types[\"required\"][\"template_type\"] == ([\"Simple\", \"Jinja2\"],)\n        --&gt;\n        \"\"\"\n        return {\n            \"required\": {\n                \"template_type\": ([\"Simple\", \"Jinja2\"],),\n                \"template\": (\"STRING\", {\"multiline\": True}),\n                \"save_path\": (\"STRING\", {\"default\": \"\"}),\n            },\n            \"hidden\": {\n                \"unique_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    @classmethod\n    def IS_CHANGED(cls, **kwargs):\n        \"\"\"\n        Determine if the node should be re-executed based on input changes.\n\n        This method is called by ComfyUI to check if the node needs to be re-calculated\n        due to changes in its inputs. It forces recalculation when Jinja2 templates\n        contain time-dependent functions.\n\n        Args:\n            **kwargs: Keyword arguments containing the node's current inputs.\n\n        Returns:\n            Any: Either the kwargs if no time-dependent functions are detected, or a random\n                 number to force recalculation.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            # This would typically be called by ComfyUI\n            result = FormatString.IS_CHANGED(template=\"Hello {name}\", template_type=\"Simple\")\n            # If no time functions detected, returns the kwargs\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; # Test with Simple template\n        &gt;&gt;&gt; result = FormatString.IS_CHANGED(template=\"Hello {name}\", template_type=\"Simple\")\n        &gt;&gt;&gt; assert isinstance(result, dict)\n        &gt;&gt;&gt; # Test with Jinja2 template containing datetime\n        &gt;&gt;&gt; result = FormatString.IS_CHANGED(template=\"Time: {{ datetime.now() }}\", template_type=\"Jinja2\")\n        &gt;&gt;&gt; assert isinstance(result, int)  # Should return a random int to force recalculation\n        --&gt;\n        \"\"\"\n        print(\"\\n[bold red]IS_CHANGED:\")\n        pprint(kwargs)\n        keys = cls._extract_keys(kwargs.get('template'))\n        print(\"Keys:\")\n        pprint(keys)\n        if kwargs.get('template_type', \"simple\") == \"Jinja2\":\n            for k in cls.additional_context.keys():\n                if k in kwargs.get('template'):\n                    # assume that our additional context items are functions returning\n                    # changing data such as datetime.now()\n                    print(f\"Detected: {k}\")\n                    return random.randrange(sys.maxsize)  # force to always recalc\n        return kwargs\n\n    @staticmethod\n    def _extract_keys(template: str) -&gt; List[str]:\n        \"\"\"\n        Extract variable names from a template string.\n\n        This method parses a template string to find all variable names used in it,\n        supporting both Python's format style {var} and Jinja2's {{ var }} syntax.\n\n        Args:\n            template (str): The template string to parse.\n\n        Returns:\n            List[str]: A list of unique variable names found in the template.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            template = \"Hello {name}, today is {{ datetime.now() }}\"\n            keys = FormatString._extract_keys(template)\n            print(keys)  # Outputs: ['name']\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; # Test simple format\n        &gt;&gt;&gt; keys = FormatString._extract_keys(\"Hello {name}, your age is {age}\")\n        &gt;&gt;&gt; assert sorted(keys) == ['age', 'name']\n        &gt;&gt;&gt; # Test Jinja2 format\n        &gt;&gt;&gt; keys = FormatString._extract_keys(\"Hello {{ name }}, {{ greeting | upper }}\")\n        &gt;&gt;&gt; assert sorted(keys) == ['greeting', 'name']\n        &gt;&gt;&gt; # Test mixed format\n        &gt;&gt;&gt; keys = FormatString._extract_keys(\"Hello {name}, today is {{ date }}\")\n        &gt;&gt;&gt; assert sorted(keys) == ['date', 'name']\n        &gt;&gt;&gt; # Test with additional context (should be excluded)\n        &gt;&gt;&gt; keys = FormatString._extract_keys(\"Time: {{ datetime.now() }}\")\n        &gt;&gt;&gt; assert keys == []\n        --&gt;\n        \"\"\"\n        variables = []\n        seen = set()\n\n        def add_var(var):\n            var = var.split('|')[0].split('.')[0].strip()\n            if var not in seen and var not in FormatString.additional_context:\n                seen.add(var)\n                variables.append(var)\n\n        # Extract variables from Jinja2 expressions {{ }}\n        for match in re.finditer(r'\\{\\{\\s*([\\w.]+)(?:\\|[\\w\\s]+)?(?:\\.[^\\(\\)]+\\(\\))?\\s*\\}\\}', template):\n            add_var(match.group(1))\n\n        # Extract variables from f-string style { }\n        for match in re.finditer(r'\\{(\\w+)\\}', template):\n            add_var(match.group(1))\n\n        # Extract variables from Jinja2 control structures {% %}\n        for structure in re.finditer(r'\\{%.*?%\\}', template):\n            for var in re.findall(r'\\b(\\w+)\\|\\b', structure.group(0)):\n                if not var.startswith('end') and var not in {'if', 'else', 'elif', 'for', 'in'}:\n                    add_var(var)\n\n        return variables\n\n    @classmethod\n    def format_string(cls, template_type: str, template: str, save_path: str, **kwargs) -&gt; Tuple[str, ...]:\n        \"\"\"\n        Format a string using the specified template type and variables.\n\n        This is the main method executed by the node. It formats the template using either\n        Python's str.format() or Jinja2 templating, and optionally saves the state to disk.\n\n        Args:\n            template_type (str): Either \"Simple\" or \"Jinja2\" to specify the template engine.\n            template (str): The template string to format.\n            save_path (str): Optional path to save the node state. If empty, state is not saved.\n            **kwargs: Variable keyword arguments that provide values for template variables.\n\n        Returns:\n            Tuple[str, ...]: A tuple containing the values of input variables, followed by\n                           the formatted string and the save path (if any).\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            # Simple template example\n            result = FormatString.format_string(\n                template_type=\"Simple\",\n                template=\"Hello {name}, you are {age} years old\",\n                save_path=\"\",\n                name=\"Alice\",\n                age=\"30\"\n            )\n            print(result)  # Outputs: ('Alice', '30', 'Hello Alice, you are 30 years old', '')\n\n            # Jinja2 template example\n            result = FormatString.format_string(\n                template_type=\"Jinja2\",\n                template=\"Hello {{ name }}, today is {{ datetime.now().strftime('%A') }}\",\n                save_path=\"\",\n                name=\"Bob\"\n            )\n            print(result[2])  # Outputs: 'Hello Bob, today is Wednesday' (or current day)\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; # Test simple format\n        &gt;&gt;&gt; result = FormatString.format_string(\n        ...     template_type=\"Simple\",\n        ...     template=\"Hello {name}, you are {age} years old\",\n        ...     save_path=\"\",\n        ...     name=\"Alice\",\n        ...     age=\"30\"\n        ... )\n        &gt;&gt;&gt; assert result[0] == \"Alice\"\n        &gt;&gt;&gt; assert result[1] == \"30\"\n        &gt;&gt;&gt; assert result[2] == \"Hello Alice, you are 30 years old\"\n        &gt;&gt;&gt; assert result[3] == \"\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Test Jinja2 format with datetime (can't test exact output due to time dependency)\n        &gt;&gt;&gt; result = FormatString.format_string(\n        ...     template_type=\"Jinja2\",\n        ...     template=\"Name: {{ name }}\",\n        ...     save_path=\"\",\n        ...     name=\"Bob\"\n        ... )\n        &gt;&gt;&gt; assert result[0] == \"Bob\"\n        &gt;&gt;&gt; assert result[1] == \"Name: Bob\"\n        &gt;&gt;&gt; assert result[2] == \"\"\n        --&gt;\n        \"\"\"\n        keys = cls._extract_keys(template)\n\n        if template_type == \"Simple\":\n            formatted_string = template.format(**kwargs)\n        else:  # Jinja2\n            try:\n                jinja_template = cls.jinja_env.from_string(template)\n                # Combine user-provided kwargs with additional_context\n                context = {**cls.additional_context, **kwargs}\n                formatted_string = jinja_template.render(**context)\n            except exceptions.TemplateSyntaxError as e:\n                formatted_string = f\"Error in Jinja2 template: {str(e)}\"\n\n        # Save the state\n        save_data = {\n            \"template_type\": template_type,\n            \"template\": template,\n            \"inputs\": {k: kwargs.get(k, \"\") for k in keys}\n        }\n\n        if save_path:\n            save_path = os.path.join(folder_paths.get_output_directory(), save_path)\n            try:\n                os.makedirs(os.path.dirname(save_path), exist_ok=True)\n                with open(save_path, \"w\") as f:\n                    json.dump(save_data, f, indent=2, sort_keys=True)\n                print(f\"Node state saved to: {save_path}\")\n            except Exception as e:\n                print(f\"Error saving node state: {str(e)}\")\n                save_path = \"\"  # Reset save_path if saving failed\n        else:\n            print(\"No save_path provided, node state not saved.\")\n\n        # Return all input values first, then formatted_string and saved_file_path\n        return tuple(str(kwargs.get(key, \"\")) for key in keys) + (formatted_string, save_path)\n\n    @classmethod\n    def update_widget(cls, node_id: str, template_type: str, template: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Update a node's widget configuration based on the template.\n\n        This method is called when a template is changed to dynamically update the\n        node's inputs and outputs based on the variables detected in the template.\n\n        Args:\n            node_id (str): The unique identifier of the node instance.\n            template_type (str): The template type (\"Simple\" or \"Jinja2\").\n            template (str): The template string.\n\n        Returns:\n            Dict[str, Any]: Updated configuration for the node.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            # Called via ComfyUI's web API when template changes\n            config = FormatString.update_widget(\n                node_id=\"node_123\",\n                template_type=\"Simple\",\n                template=\"Hello {name}, you are {age} years old\"\n            )\n            print(config[\"inputs\"])  # Shows inputs including 'name' and 'age'\n            print(config[\"outputs\"])  # Shows outputs including extracted variables\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; config = FormatString.update_widget(\n        ...     node_id=\"test_node\",\n        ...     template_type=\"Simple\",\n        ...     template=\"Hello {name}, you are {age} years old\"\n        ... )\n        &gt;&gt;&gt; assert \"name\" in config[\"inputs\"]\n        &gt;&gt;&gt; assert \"age\" in config[\"inputs\"]\n        &gt;&gt;&gt; assert len(config[\"outputs\"]) == 4  # name, age, formatted_string, saved_file_path\n        &gt;&gt;&gt; assert config[\"outputs\"][0][\"name\"] == \"name\"\n        &gt;&gt;&gt; assert config[\"outputs\"][1][\"name\"] == \"age\"\n        &gt;&gt;&gt; assert config[\"outputs\"][2][\"name\"] == \"formatted_string\"\n        &gt;&gt;&gt; assert config[\"outputs\"][3][\"name\"] == \"saved_file_path\"\n        &gt;&gt;&gt; # Check that RETURN_TYPES and RETURN_NAMES are updated\n        &gt;&gt;&gt; assert len(FormatString.RETURN_TYPES) == 4\n        &gt;&gt;&gt; assert len(FormatString.RETURN_NAMES) == 4\n        &gt;&gt;&gt; assert FormatString.RETURN_NAMES[0] == \"name\"\n        &gt;&gt;&gt; assert FormatString.RETURN_NAMES[1] == \"age\"\n        &gt;&gt;&gt; assert FormatString.RETURN_NAMES[2] == \"formatted_string\"\n        &gt;&gt;&gt; assert FormatString.RETURN_NAMES[3] == \"saved_file_path\"\n        &gt;&gt;&gt; # Check that node config is stored\n        &gt;&gt;&gt; assert \"test_node\" in FormatString.node_configs\n        &gt;&gt;&gt; assert FormatString.node_configs[\"test_node\"] == config\n        --&gt;\n        \"\"\"\n        keys = cls._extract_keys(template)\n        config = {\n            \"inputs\": {\n                \"template_type\": ([\"Simple\", \"Jinja2\"],),\n                \"template\": (\"STRING\", {\"multiline\": True}),\n                \"save_path\": (\"STRING\", {\"default\": \"\"}),\n            },\n            \"outputs\": [],\n        }\n        for key in keys:\n            config[\"inputs\"][key] = (\"STRING\", {\"default\": \"\"})\n            config[\"outputs\"].append({\"name\": key, \"type\": \"STRING\"})\n\n        # Add formatted_string and saved_file_path at the end of outputs\n        config[\"outputs\"].extend([\n            {\"name\": \"formatted_string\", \"type\": \"STRING\"},\n            {\"name\": \"saved_file_path\", \"type\": \"STRING\"},\n        ])\n\n        # Update RETURN_TYPES and RETURN_NAMES\n        cls.RETURN_TYPES = (\"STRING\",) * len(keys) + (\"STRING\", \"STRING\")\n        cls.RETURN_NAMES = tuple(keys) + (\"formatted_string\", \"saved_file_path\")\n\n        # Store the configuration for this specific node\n        cls.node_configs[node_id] = config\n\n        return config\n\n    @classmethod\n    def get_node_config(cls, node_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the configuration for a specific node instance.\n\n        Args:\n            node_id (str): The unique identifier of the node instance.\n\n        Returns:\n            Dict[str, Any]: The configuration for the specified node, or an empty dict if not found.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            # After updating a node's configuration\n            config = FormatString.get_node_config(\"node_123\")\n            print(config)  # Shows the stored configuration for node_123\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; # First create a config\n        &gt;&gt;&gt; _ = FormatString.update_widget(\n        ...     node_id=\"test_node_2\",\n        ...     template_type=\"Simple\",\n        ...     template=\"Hello {name}\"\n        ... )\n        &gt;&gt;&gt; # Then retrieve it\n        &gt;&gt;&gt; config = FormatString.get_node_config(\"test_node_2\")\n        &gt;&gt;&gt; assert \"inputs\" in config\n        &gt;&gt;&gt; assert \"outputs\" in config\n        &gt;&gt;&gt; assert \"name\" in config[\"inputs\"]\n        &gt;&gt;&gt; assert len(config[\"outputs\"]) == 3  # name, formatted_string, saved_file_path\n        &gt;&gt;&gt; # Test non-existent node\n        &gt;&gt;&gt; empty_config = FormatString.get_node_config(\"non_existent_node\")\n        &gt;&gt;&gt; assert empty_config == {}\n        --&gt;\n        \"\"\"\n        return cls.node_configs.get(node_id, {})\n\n    @classmethod\n    def load_node_state(cls, file_path: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Load a previously saved node state from disk.\n\n        Args:\n            file_path (str): Path to the saved node state JSON file.\n\n        Returns:\n            Dict[str, Any]: The loaded node state, or an empty dict if loading failed.\n\n        Example:\n            ```python\n            from format_string import FormatString\n\n            # Load a previously saved state\n            state = FormatString.load_node_state(\"/path/to/saved_state.json\")\n            print(state[\"template\"])  # Shows the saved template\n            print(state[\"inputs\"])    # Shows the saved input values\n            ```\n\n        &lt;!-- Example Test:\n        &gt;&gt;&gt; import tempfile\n        &gt;&gt;&gt; import json\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; # Create a temporary file with test data\n        &gt;&gt;&gt; test_data = {\n        ...     \"template_type\": \"Simple\",\n        ...     \"template\": \"Hello {name}\",\n        ...     \"inputs\": {\"name\": \"Alice\"}\n        ... }\n        &gt;&gt;&gt; with tempfile.NamedTemporaryFile(delete=False, mode=\"w\") as temp:\n        ...     json.dump(test_data, temp)\n        ...     temp_path = temp.name\n        &gt;&gt;&gt; # Test loading the file\n        &gt;&gt;&gt; state = FormatString.load_node_state(temp_path)\n        &gt;&gt;&gt; assert state[\"template_type\"] == \"Simple\"\n        &gt;&gt;&gt; assert state[\"template\"] == \"Hello {name}\"\n        &gt;&gt;&gt; assert state[\"inputs\"][\"name\"] == \"Alice\"\n        &gt;&gt;&gt; # Clean up\n        &gt;&gt;&gt; os.unlink(temp_path)\n        &gt;&gt;&gt; # Test loading non-existent file\n        &gt;&gt;&gt; empty_state = FormatString.load_node_state(\"non_existent_file.json\")\n        &gt;&gt;&gt; assert empty_state == {}\n        --&gt;\n        \"\"\"\n        try:\n            with open(file_path, \"r\") as f:\n                load_data = json.load(f)\n            return load_data\n        except FileNotFoundError:\n            return {}\n        except Exception as e:\n            print(f\"Error loading node state: {e}\")\n            return {}\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.INPUT_TYPES","title":"<code>INPUT_TYPES()</code>  <code>classmethod</code>","text":"<p>Define the input types for the FormatString node.</p> <p>This method is called by ComfyUI to determine what inputs the node should have.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary defining the node's inputs, including template_type,            template, save_path, and a hidden unique_id.</p> Example <pre><code>from format_string import FormatString\n\ninput_types = FormatString.INPUT_TYPES()\nprint(input_types[\"required\"][\"template_type\"])  # Outputs: ([\"Simple\", \"Jinja2\"],)\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef INPUT_TYPES(cls) -&gt; Dict[str, Any]:\n    \"\"\"\n    Define the input types for the FormatString node.\n\n    This method is called by ComfyUI to determine what inputs the node should have.\n\n    Returns:\n        Dict[str, Any]: Dictionary defining the node's inputs, including template_type,\n                       template, save_path, and a hidden unique_id.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        input_types = FormatString.INPUT_TYPES()\n        print(input_types[\"required\"][\"template_type\"])  # Outputs: ([\"Simple\", \"Jinja2\"],)\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; input_types = FormatString.INPUT_TYPES()\n    &gt;&gt;&gt; assert \"required\" in input_types\n    &gt;&gt;&gt; assert \"template_type\" in input_types[\"required\"]\n    &gt;&gt;&gt; assert \"template\" in input_types[\"required\"]\n    &gt;&gt;&gt; assert \"save_path\" in input_types[\"required\"]\n    &gt;&gt;&gt; assert \"hidden\" in input_types\n    &gt;&gt;&gt; assert \"unique_id\" in input_types[\"hidden\"]\n    &gt;&gt;&gt; assert input_types[\"required\"][\"template_type\"] == ([\"Simple\", \"Jinja2\"],)\n    --&gt;\n    \"\"\"\n    return {\n        \"required\": {\n            \"template_type\": ([\"Simple\", \"Jinja2\"],),\n            \"template\": (\"STRING\", {\"multiline\": True}),\n            \"save_path\": (\"STRING\", {\"default\": \"\"}),\n        },\n        \"hidden\": {\n            \"unique_id\": \"UNIQUE_ID\"\n        }\n    }\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.IS_CHANGED","title":"<code>IS_CHANGED(**kwargs)</code>  <code>classmethod</code>","text":"<p>Determine if the node should be re-executed based on input changes.</p> <p>This method is called by ComfyUI to check if the node needs to be re-calculated due to changes in its inputs. It forces recalculation when Jinja2 templates contain time-dependent functions.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments containing the node's current inputs.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>Either the kwargs if no time-dependent functions are detected, or a random  number to force recalculation.</p> Example <pre><code>from format_string import FormatString\n\n# This would typically be called by ComfyUI\nresult = FormatString.IS_CHANGED(template=\"Hello {name}\", template_type=\"Simple\")\n# If no time functions detected, returns the kwargs\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef IS_CHANGED(cls, **kwargs):\n    \"\"\"\n    Determine if the node should be re-executed based on input changes.\n\n    This method is called by ComfyUI to check if the node needs to be re-calculated\n    due to changes in its inputs. It forces recalculation when Jinja2 templates\n    contain time-dependent functions.\n\n    Args:\n        **kwargs: Keyword arguments containing the node's current inputs.\n\n    Returns:\n        Any: Either the kwargs if no time-dependent functions are detected, or a random\n             number to force recalculation.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        # This would typically be called by ComfyUI\n        result = FormatString.IS_CHANGED(template=\"Hello {name}\", template_type=\"Simple\")\n        # If no time functions detected, returns the kwargs\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; # Test with Simple template\n    &gt;&gt;&gt; result = FormatString.IS_CHANGED(template=\"Hello {name}\", template_type=\"Simple\")\n    &gt;&gt;&gt; assert isinstance(result, dict)\n    &gt;&gt;&gt; # Test with Jinja2 template containing datetime\n    &gt;&gt;&gt; result = FormatString.IS_CHANGED(template=\"Time: {{ datetime.now() }}\", template_type=\"Jinja2\")\n    &gt;&gt;&gt; assert isinstance(result, int)  # Should return a random int to force recalculation\n    --&gt;\n    \"\"\"\n    print(\"\\n[bold red]IS_CHANGED:\")\n    pprint(kwargs)\n    keys = cls._extract_keys(kwargs.get('template'))\n    print(\"Keys:\")\n    pprint(keys)\n    if kwargs.get('template_type', \"simple\") == \"Jinja2\":\n        for k in cls.additional_context.keys():\n            if k in kwargs.get('template'):\n                # assume that our additional context items are functions returning\n                # changing data such as datetime.now()\n                print(f\"Detected: {k}\")\n                return random.randrange(sys.maxsize)  # force to always recalc\n    return kwargs\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.format_string","title":"<code>format_string(template_type, template, save_path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Format a string using the specified template type and variables.</p> <p>This is the main method executed by the node. It formats the template using either Python's str.format() or Jinja2 templating, and optionally saves the state to disk.</p> <p>Parameters:</p> Name Type Description Default <code>template_type</code> <code>str</code> <p>Either \"Simple\" or \"Jinja2\" to specify the template engine.</p> required <code>template</code> <code>str</code> <p>The template string to format.</p> required <code>save_path</code> <code>str</code> <p>Optional path to save the node state. If empty, state is not saved.</p> required <code>**kwargs</code> <p>Variable keyword arguments that provide values for template variables.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Tuple[str, ...]: A tuple containing the values of input variables, followed by            the formatted string and the save path (if any).</p> Example <pre><code>from format_string import FormatString\n\n# Simple template example\nresult = FormatString.format_string(\n    template_type=\"Simple\",\n    template=\"Hello {name}, you are {age} years old\",\n    save_path=\"\",\n    name=\"Alice\",\n    age=\"30\"\n)\nprint(result)  # Outputs: ('Alice', '30', 'Hello Alice, you are 30 years old', '')\n\n# Jinja2 template example\nresult = FormatString.format_string(\n    template_type=\"Jinja2\",\n    template=\"Hello {{ name }}, today is {{ datetime.now().strftime('%A') }}\",\n    save_path=\"\",\n    name=\"Bob\"\n)\nprint(result[2])  # Outputs: 'Hello Bob, today is Wednesday' (or current day)\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef format_string(cls, template_type: str, template: str, save_path: str, **kwargs) -&gt; Tuple[str, ...]:\n    \"\"\"\n    Format a string using the specified template type and variables.\n\n    This is the main method executed by the node. It formats the template using either\n    Python's str.format() or Jinja2 templating, and optionally saves the state to disk.\n\n    Args:\n        template_type (str): Either \"Simple\" or \"Jinja2\" to specify the template engine.\n        template (str): The template string to format.\n        save_path (str): Optional path to save the node state. If empty, state is not saved.\n        **kwargs: Variable keyword arguments that provide values for template variables.\n\n    Returns:\n        Tuple[str, ...]: A tuple containing the values of input variables, followed by\n                       the formatted string and the save path (if any).\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        # Simple template example\n        result = FormatString.format_string(\n            template_type=\"Simple\",\n            template=\"Hello {name}, you are {age} years old\",\n            save_path=\"\",\n            name=\"Alice\",\n            age=\"30\"\n        )\n        print(result)  # Outputs: ('Alice', '30', 'Hello Alice, you are 30 years old', '')\n\n        # Jinja2 template example\n        result = FormatString.format_string(\n            template_type=\"Jinja2\",\n            template=\"Hello {{ name }}, today is {{ datetime.now().strftime('%A') }}\",\n            save_path=\"\",\n            name=\"Bob\"\n        )\n        print(result[2])  # Outputs: 'Hello Bob, today is Wednesday' (or current day)\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; # Test simple format\n    &gt;&gt;&gt; result = FormatString.format_string(\n    ...     template_type=\"Simple\",\n    ...     template=\"Hello {name}, you are {age} years old\",\n    ...     save_path=\"\",\n    ...     name=\"Alice\",\n    ...     age=\"30\"\n    ... )\n    &gt;&gt;&gt; assert result[0] == \"Alice\"\n    &gt;&gt;&gt; assert result[1] == \"30\"\n    &gt;&gt;&gt; assert result[2] == \"Hello Alice, you are 30 years old\"\n    &gt;&gt;&gt; assert result[3] == \"\"\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Test Jinja2 format with datetime (can't test exact output due to time dependency)\n    &gt;&gt;&gt; result = FormatString.format_string(\n    ...     template_type=\"Jinja2\",\n    ...     template=\"Name: {{ name }}\",\n    ...     save_path=\"\",\n    ...     name=\"Bob\"\n    ... )\n    &gt;&gt;&gt; assert result[0] == \"Bob\"\n    &gt;&gt;&gt; assert result[1] == \"Name: Bob\"\n    &gt;&gt;&gt; assert result[2] == \"\"\n    --&gt;\n    \"\"\"\n    keys = cls._extract_keys(template)\n\n    if template_type == \"Simple\":\n        formatted_string = template.format(**kwargs)\n    else:  # Jinja2\n        try:\n            jinja_template = cls.jinja_env.from_string(template)\n            # Combine user-provided kwargs with additional_context\n            context = {**cls.additional_context, **kwargs}\n            formatted_string = jinja_template.render(**context)\n        except exceptions.TemplateSyntaxError as e:\n            formatted_string = f\"Error in Jinja2 template: {str(e)}\"\n\n    # Save the state\n    save_data = {\n        \"template_type\": template_type,\n        \"template\": template,\n        \"inputs\": {k: kwargs.get(k, \"\") for k in keys}\n    }\n\n    if save_path:\n        save_path = os.path.join(folder_paths.get_output_directory(), save_path)\n        try:\n            os.makedirs(os.path.dirname(save_path), exist_ok=True)\n            with open(save_path, \"w\") as f:\n                json.dump(save_data, f, indent=2, sort_keys=True)\n            print(f\"Node state saved to: {save_path}\")\n        except Exception as e:\n            print(f\"Error saving node state: {str(e)}\")\n            save_path = \"\"  # Reset save_path if saving failed\n    else:\n        print(\"No save_path provided, node state not saved.\")\n\n    # Return all input values first, then formatted_string and saved_file_path\n    return tuple(str(kwargs.get(key, \"\")) for key in keys) + (formatted_string, save_path)\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.get_node_config","title":"<code>get_node_config(node_id)</code>  <code>classmethod</code>","text":"<p>Get the configuration for a specific node instance.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The unique identifier of the node instance.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The configuration for the specified node, or an empty dict if not found.</p> Example <pre><code>from format_string import FormatString\n\n# After updating a node's configuration\nconfig = FormatString.get_node_config(\"node_123\")\nprint(config)  # Shows the stored configuration for node_123\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef get_node_config(cls, node_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the configuration for a specific node instance.\n\n    Args:\n        node_id (str): The unique identifier of the node instance.\n\n    Returns:\n        Dict[str, Any]: The configuration for the specified node, or an empty dict if not found.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        # After updating a node's configuration\n        config = FormatString.get_node_config(\"node_123\")\n        print(config)  # Shows the stored configuration for node_123\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; # First create a config\n    &gt;&gt;&gt; _ = FormatString.update_widget(\n    ...     node_id=\"test_node_2\",\n    ...     template_type=\"Simple\",\n    ...     template=\"Hello {name}\"\n    ... )\n    &gt;&gt;&gt; # Then retrieve it\n    &gt;&gt;&gt; config = FormatString.get_node_config(\"test_node_2\")\n    &gt;&gt;&gt; assert \"inputs\" in config\n    &gt;&gt;&gt; assert \"outputs\" in config\n    &gt;&gt;&gt; assert \"name\" in config[\"inputs\"]\n    &gt;&gt;&gt; assert len(config[\"outputs\"]) == 3  # name, formatted_string, saved_file_path\n    &gt;&gt;&gt; # Test non-existent node\n    &gt;&gt;&gt; empty_config = FormatString.get_node_config(\"non_existent_node\")\n    &gt;&gt;&gt; assert empty_config == {}\n    --&gt;\n    \"\"\"\n    return cls.node_configs.get(node_id, {})\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.load_node_state","title":"<code>load_node_state(file_path)</code>  <code>classmethod</code>","text":"<p>Load a previously saved node state from disk.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the saved node state JSON file.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The loaded node state, or an empty dict if loading failed.</p> Example <pre><code>from format_string import FormatString\n\n# Load a previously saved state\nstate = FormatString.load_node_state(\"/path/to/saved_state.json\")\nprint(state[\"template\"])  # Shows the saved template\nprint(state[\"inputs\"])    # Shows the saved input values\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef load_node_state(cls, file_path: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load a previously saved node state from disk.\n\n    Args:\n        file_path (str): Path to the saved node state JSON file.\n\n    Returns:\n        Dict[str, Any]: The loaded node state, or an empty dict if loading failed.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        # Load a previously saved state\n        state = FormatString.load_node_state(\"/path/to/saved_state.json\")\n        print(state[\"template\"])  # Shows the saved template\n        print(state[\"inputs\"])    # Shows the saved input values\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; import tempfile\n    &gt;&gt;&gt; import json\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; # Create a temporary file with test data\n    &gt;&gt;&gt; test_data = {\n    ...     \"template_type\": \"Simple\",\n    ...     \"template\": \"Hello {name}\",\n    ...     \"inputs\": {\"name\": \"Alice\"}\n    ... }\n    &gt;&gt;&gt; with tempfile.NamedTemporaryFile(delete=False, mode=\"w\") as temp:\n    ...     json.dump(test_data, temp)\n    ...     temp_path = temp.name\n    &gt;&gt;&gt; # Test loading the file\n    &gt;&gt;&gt; state = FormatString.load_node_state(temp_path)\n    &gt;&gt;&gt; assert state[\"template_type\"] == \"Simple\"\n    &gt;&gt;&gt; assert state[\"template\"] == \"Hello {name}\"\n    &gt;&gt;&gt; assert state[\"inputs\"][\"name\"] == \"Alice\"\n    &gt;&gt;&gt; # Clean up\n    &gt;&gt;&gt; os.unlink(temp_path)\n    &gt;&gt;&gt; # Test loading non-existent file\n    &gt;&gt;&gt; empty_state = FormatString.load_node_state(\"non_existent_file.json\")\n    &gt;&gt;&gt; assert empty_state == {}\n    --&gt;\n    \"\"\"\n    try:\n        with open(file_path, \"r\") as f:\n            load_data = json.load(f)\n        return load_data\n    except FileNotFoundError:\n        return {}\n    except Exception as e:\n        print(f\"Error loading node state: {e}\")\n        return {}\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.time_now","title":"<code>time_now()</code>","text":"<p>Get the current time in a formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Current time formatted as 'YYYYMMDD-HHMMSS'.</p> Example <pre><code>from format_string import FormatString\n\ntimestamp = FormatString.time_now()\nprint(timestamp)  # Outputs something like: '20240327-153045'\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>def time_now() -&gt; str:\n    \"\"\"\n    Get the current time in a formatted string.\n\n    Returns:\n        str: Current time formatted as 'YYYYMMDD-HHMMSS'.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        timestamp = FormatString.time_now()\n        print(timestamp)  # Outputs something like: '20240327-153045'\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; from datetime import datetime\n    &gt;&gt;&gt; timestamp = FormatString.time_now()\n    &gt;&gt;&gt; assert len(timestamp) == 15  # Format YYYYMMDD-HHMMSS is 15 chars\n    &gt;&gt;&gt; assert timestamp[8] == '-'  # Check format separator\n    &gt;&gt;&gt; # Verify it's roughly the current time (allowing some seconds of delay)\n    &gt;&gt;&gt; current = datetime.now().strftime(\"%Y%m%d-%H%M\")\n    &gt;&gt;&gt; assert timestamp.startswith(current)\n    --&gt;\n    \"\"\"\n    return datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.FormatString.update_widget","title":"<code>update_widget(node_id, template_type, template)</code>  <code>classmethod</code>","text":"<p>Update a node's widget configuration based on the template.</p> <p>This method is called when a template is changed to dynamically update the node's inputs and outputs based on the variables detected in the template.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The unique identifier of the node instance.</p> required <code>template_type</code> <code>str</code> <p>The template type (\"Simple\" or \"Jinja2\").</p> required <code>template</code> <code>str</code> <p>The template string.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Updated configuration for the node.</p> Example <pre><code>from format_string import FormatString\n\n# Called via ComfyUI's web API when template changes\nconfig = FormatString.update_widget(\n    node_id=\"node_123\",\n    template_type=\"Simple\",\n    template=\"Hello {name}, you are {age} years old\"\n)\nprint(config[\"inputs\"])  # Shows inputs including 'name' and 'age'\nprint(config[\"outputs\"])  # Shows outputs including extracted variables\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@classmethod\ndef update_widget(cls, node_id: str, template_type: str, template: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Update a node's widget configuration based on the template.\n\n    This method is called when a template is changed to dynamically update the\n    node's inputs and outputs based on the variables detected in the template.\n\n    Args:\n        node_id (str): The unique identifier of the node instance.\n        template_type (str): The template type (\"Simple\" or \"Jinja2\").\n        template (str): The template string.\n\n    Returns:\n        Dict[str, Any]: Updated configuration for the node.\n\n    Example:\n        ```python\n        from format_string import FormatString\n\n        # Called via ComfyUI's web API when template changes\n        config = FormatString.update_widget(\n            node_id=\"node_123\",\n            template_type=\"Simple\",\n            template=\"Hello {name}, you are {age} years old\"\n        )\n        print(config[\"inputs\"])  # Shows inputs including 'name' and 'age'\n        print(config[\"outputs\"])  # Shows outputs including extracted variables\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; config = FormatString.update_widget(\n    ...     node_id=\"test_node\",\n    ...     template_type=\"Simple\",\n    ...     template=\"Hello {name}, you are {age} years old\"\n    ... )\n    &gt;&gt;&gt; assert \"name\" in config[\"inputs\"]\n    &gt;&gt;&gt; assert \"age\" in config[\"inputs\"]\n    &gt;&gt;&gt; assert len(config[\"outputs\"]) == 4  # name, age, formatted_string, saved_file_path\n    &gt;&gt;&gt; assert config[\"outputs\"][0][\"name\"] == \"name\"\n    &gt;&gt;&gt; assert config[\"outputs\"][1][\"name\"] == \"age\"\n    &gt;&gt;&gt; assert config[\"outputs\"][2][\"name\"] == \"formatted_string\"\n    &gt;&gt;&gt; assert config[\"outputs\"][3][\"name\"] == \"saved_file_path\"\n    &gt;&gt;&gt; # Check that RETURN_TYPES and RETURN_NAMES are updated\n    &gt;&gt;&gt; assert len(FormatString.RETURN_TYPES) == 4\n    &gt;&gt;&gt; assert len(FormatString.RETURN_NAMES) == 4\n    &gt;&gt;&gt; assert FormatString.RETURN_NAMES[0] == \"name\"\n    &gt;&gt;&gt; assert FormatString.RETURN_NAMES[1] == \"age\"\n    &gt;&gt;&gt; assert FormatString.RETURN_NAMES[2] == \"formatted_string\"\n    &gt;&gt;&gt; assert FormatString.RETURN_NAMES[3] == \"saved_file_path\"\n    &gt;&gt;&gt; # Check that node config is stored\n    &gt;&gt;&gt; assert \"test_node\" in FormatString.node_configs\n    &gt;&gt;&gt; assert FormatString.node_configs[\"test_node\"] == config\n    --&gt;\n    \"\"\"\n    keys = cls._extract_keys(template)\n    config = {\n        \"inputs\": {\n            \"template_type\": ([\"Simple\", \"Jinja2\"],),\n            \"template\": (\"STRING\", {\"multiline\": True}),\n            \"save_path\": (\"STRING\", {\"default\": \"\"}),\n        },\n        \"outputs\": [],\n    }\n    for key in keys:\n        config[\"inputs\"][key] = (\"STRING\", {\"default\": \"\"})\n        config[\"outputs\"].append({\"name\": key, \"type\": \"STRING\"})\n\n    # Add formatted_string and saved_file_path at the end of outputs\n    config[\"outputs\"].extend([\n        {\"name\": \"formatted_string\", \"type\": \"STRING\"},\n        {\"name\": \"saved_file_path\", \"type\": \"STRING\"},\n    ])\n\n    # Update RETURN_TYPES and RETURN_NAMES\n    cls.RETURN_TYPES = (\"STRING\",) * len(keys) + (\"STRING\", \"STRING\")\n    cls.RETURN_NAMES = tuple(keys) + (\"formatted_string\", \"saved_file_path\")\n\n    # Store the configuration for this specific node\n    cls.node_configs[node_id] = config\n\n    return config\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.get_format_string_node_config","title":"<code>get_format_string_node_config(request)</code>  <code>async</code>","text":"<p>AIOHTTP route handler for retrieving a FormatString node's configuration.</p> <p>This endpoint retrieves the stored configuration for a specific node instance.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request object containing the node ID in the URL.</p> required <p>Returns:</p> Type Description <p>web.Response: JSON response with the node's configuration.</p> Example <p>This would typically be called by the frontend JavaScript via a GET request:</p> <pre><code>// In ComfyUI frontend\nfetch(\"/get_format_string_node_config/node_123\")\n  .then(response =&gt; response.json())\n  .then(data =&gt; console.log(data));\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@PromptServer.instance.routes.get(\"/get_format_string_node_config/{node_id}\")\nasync def get_format_string_node_config(request):\n    \"\"\"\n    AIOHTTP route handler for retrieving a FormatString node's configuration.\n\n    This endpoint retrieves the stored configuration for a specific node instance.\n\n    Args:\n        request (web.Request): The HTTP request object containing the node ID in the URL.\n\n    Returns:\n        web.Response: JSON response with the node's configuration.\n\n    Example:\n        This would typically be called by the frontend JavaScript via a GET request:\n\n        ```javascript\n        // In ComfyUI frontend\n        fetch(\"/get_format_string_node_config/node_123\")\n          .then(response =&gt; response.json())\n          .then(data =&gt; console.log(data));\n        ```\n    \"\"\"\n    node_id = request.match_info['node_id']\n    config = FormatString.get_node_config(node_id)\n    return web.json_response(config)\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.load_format_string_node","title":"<code>load_format_string_node(request)</code>  <code>async</code>","text":"<p>AIOHTTP route handler for loading a FormatString node's state from disk.</p> <p>This endpoint receives JSON data containing a file path, then loads and returns the node state from that file.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request object containing JSON data.</p> required <p>Returns:</p> Type Description <p>web.Response: JSON response with the loaded node state.</p> Example <p>This would typically be called by the frontend JavaScript via a POST request:</p> <pre><code>// In ComfyUI frontend\nfetch(\"/load_format_string_node\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n        file_path: \"/path/to/saved_state.json\"\n    })\n}).then(response =&gt; response.json())\n  .then(data =&gt; console.log(data));\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@PromptServer.instance.routes.post(\"/load_format_string_node\")\nasync def load_format_string_node(request):\n    \"\"\"\n    AIOHTTP route handler for loading a FormatString node's state from disk.\n\n    This endpoint receives JSON data containing a file path, then loads and returns\n    the node state from that file.\n\n    Args:\n        request (web.Request): The HTTP request object containing JSON data.\n\n    Returns:\n        web.Response: JSON response with the loaded node state.\n\n    Example:\n        This would typically be called by the frontend JavaScript via a POST request:\n\n        ```javascript\n        // In ComfyUI frontend\n        fetch(\"/load_format_string_node\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                file_path: \"/path/to/saved_state.json\"\n            })\n        }).then(response =&gt; response.json())\n          .then(data =&gt; console.log(data));\n        ```\n    \"\"\"\n    data = await request.json()\n    file_path = data.get('file_path', '')\n    state = FormatString.load_node_state(file_path)\n    return web.json_response(state)\n</code></pre>"},{"location":"reference/comfydv/format_string/#comfydv.format_string.update_format_string_node","title":"<code>update_format_string_node(request)</code>  <code>async</code>","text":"<p>AIOHTTP route handler for updating a FormatString node's configuration.</p> <p>This endpoint receives JSON data containing a node ID, template type, and template, then updates the node's configuration based on the template.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request object containing JSON data.</p> required <p>Returns:</p> Type Description <p>web.Response: JSON response with the updated node configuration.</p> Example <p>This would typically be called by the frontend JavaScript via a POST request:</p> <pre><code>// In ComfyUI frontend\nfetch(\"/update_format_string_node\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n        nodeId: \"node_123\",\n        template_type: \"Simple\",\n        template: \"Hello {name}\"\n    })\n}).then(response =&gt; response.json())\n  .then(data =&gt; console.log(data));\n</code></pre> Source code in <code>src/comfydv/format_string.py</code> <pre><code>@PromptServer.instance.routes.post(\"/update_format_string_node\")\nasync def update_format_string_node(request):\n    \"\"\"\n    AIOHTTP route handler for updating a FormatString node's configuration.\n\n    This endpoint receives JSON data containing a node ID, template type, and template,\n    then updates the node's configuration based on the template.\n\n    Args:\n        request (web.Request): The HTTP request object containing JSON data.\n\n    Returns:\n        web.Response: JSON response with the updated node configuration.\n\n    Example:\n        This would typically be called by the frontend JavaScript via a POST request:\n\n        ```javascript\n        // In ComfyUI frontend\n        fetch(\"/update_format_string_node\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                nodeId: \"node_123\",\n                template_type: \"Simple\",\n                template: \"Hello {name}\"\n            })\n        }).then(response =&gt; response.json())\n          .then(data =&gt; console.log(data));\n        ```\n    \"\"\"\n    data = await request.json()\n    node_id = data.get('nodeId', '')\n    template_type = data.get('template_type', '')\n    template = data.get('template', '')\n    updated_config = FormatString.update_widget(node_id, template_type, template)\n    return web.json_response(updated_config)\n</code></pre>"},{"location":"reference/comfydv/model_unload/","title":"model_unload","text":""},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.ModelUnloader","title":"<code>ModelUnloader</code>","text":"<p>A custom node that handles unloading models, clearing GPU/CPU memory, and calling the ComfyUI /free API endpoint to release memory resources. The API endpoint can be configured by the user.</p> Source code in <code>src/comfydv/model_unload.py</code> <pre><code>class ModelUnloader:\n    \"\"\"\n    A custom node that handles unloading models, clearing GPU/CPU memory, and calling\n    the ComfyUI /free API endpoint to release memory resources. The API endpoint can\n    be configured by the user.\n    \"\"\"\n\n    RETURN_TYPES = (any_type,)\n    RETURN_NAMES = (\"passthrough\",)\n    FUNCTION = \"unload_model\"\n    OUTPUT_NODE = True\n    CATEGORY = \"dv/experimental\"\n\n    def __init__(self):\n        \"\"\"Initializes the ModelUnloader class.\"\"\"\n        pass\n\n    @classmethod\n    def INPUT_TYPES(cls):\n        \"\"\"\n        Defines the input types for the node, including a required API URL to specify where\n        the /free API call should be made.\n\n        Returns:\n            dict: A dictionary with input field configurations.\n        \"\"\"\n        return {\n            \"required\": {\n                \"trigger\": (any_type,),\n                \"api_url\": (\"STRING\", {\"default\": \"http://localhost:8188\"}),\n            },\n            \"optional\": {\"model\": (\"MODEL\", {})},\n        }\n\n    @classmethod\n    def IS_CHANGED(s, **kwargs):\n        return random.randrange(sys.maxsize)  # force to always recalc\n\n    def unload_model(self, trigger, api_url: str, **kwargs):\n        \"\"\"\n        Unloads models, clears backend-specific memory caches, and calls the /free API to release memory.\n\n        Args:\n            api_url (str): The API URL where the /free endpoint can be accessed.\n            kwargs: Optional arguments to specify which model to unload.\n        \"\"\"\n        # Unload models via ComfyUI model management\n        print(\"Attempting to unload models...\")\n        model_to_unload = kwargs.get(\"model\")\n        print(f\"Unloading {model_to_unload}\") if model_to_unload else None\n        loaded_models = model_management.current_loaded_models\n        [\n            pprint(\n                {\n                    \"model\": m.model,\n                    \"device\": m.device,\n                    \"weights_loaded\": m.weights_loaded,\n                    \"currently_used\": m.currently_used,\n                    \"real_model\": str(m.real_model)[:100],\n                },\n                max_depth=1,\n                max_length=5,\n            )\n            for m in loaded_models\n        ]\n\n        if model_to_unload:\n            for m in loaded_models:\n                if m.model == model_to_unload:\n                    print(f\"Unloading model: {m.model}\")\n                    m.model_unload()\n        else:\n            print(\"No specific model provided, unloading all models.\")\n            for m in loaded_models:\n                m.model_unload()\n\n        # Clear CUDA/MPS/CPU memory and call /free API\n        self.clear_memory(api_url)\n\n        # Call soft_empty_cache to clear ComfyUI's internal model cache\n        print(\"Calling soft_empty_cache from ComfyUI model_management.\")\n        model_management.soft_empty_cache()\n\n        return (trigger,)\n\n    def clear_memory(self, api_url: str):\n        \"\"\"\n        Clears memory based on the detected device backend (CUDA, MPS, CPU) and sends a /free API request.\n\n        Args:\n            api_url (str): The API URL where the /free endpoint can be accessed.\n        \"\"\"\n        device = get_best_pytorch_device()\n\n        # CUDA backend\n        if device.type == \"cuda\":\n            print(\"Clearing CUDA memory cache...\")\n            torch.cuda.empty_cache()\n\n        # Call model_management's soft_empty_cache for ComfyUI\n        print(\"Calling soft_empty_cache from ComfyUI model_management...\")\n        model_management.soft_empty_cache()\n\n        # Make the /free API call to ensure models are unloaded and memory is freed\n        try:\n            print(f\"Calling /free API at {api_url} to unload models and free memory...\")\n            response = requests.post(\n                f\"{api_url}/free\",  # Use the user-configured API URL\n                json={\"unload_models\": True, \"free_memory\": True},\n            )\n            if response.status_code == 200:\n                print(\"/free API call successful.\")\n            else:\n                print(f\"/free API call failed with status code {response.status_code}.\")\n        except Exception as e:\n            print(f\"Failed to call /free API: {e}\")\n</code></pre>"},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.ModelUnloader.INPUT_TYPES","title":"<code>INPUT_TYPES()</code>  <code>classmethod</code>","text":"<p>Defines the input types for the node, including a required API URL to specify where the /free API call should be made.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with input field configurations.</p> Source code in <code>src/comfydv/model_unload.py</code> <pre><code>@classmethod\ndef INPUT_TYPES(cls):\n    \"\"\"\n    Defines the input types for the node, including a required API URL to specify where\n    the /free API call should be made.\n\n    Returns:\n        dict: A dictionary with input field configurations.\n    \"\"\"\n    return {\n        \"required\": {\n            \"trigger\": (any_type,),\n            \"api_url\": (\"STRING\", {\"default\": \"http://localhost:8188\"}),\n        },\n        \"optional\": {\"model\": (\"MODEL\", {})},\n    }\n</code></pre>"},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.ModelUnloader.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ModelUnloader class.</p> Source code in <code>src/comfydv/model_unload.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the ModelUnloader class.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.ModelUnloader.clear_memory","title":"<code>clear_memory(api_url)</code>","text":"<p>Clears memory based on the detected device backend (CUDA, MPS, CPU) and sends a /free API request.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>The API URL where the /free endpoint can be accessed.</p> required Source code in <code>src/comfydv/model_unload.py</code> <pre><code>def clear_memory(self, api_url: str):\n    \"\"\"\n    Clears memory based on the detected device backend (CUDA, MPS, CPU) and sends a /free API request.\n\n    Args:\n        api_url (str): The API URL where the /free endpoint can be accessed.\n    \"\"\"\n    device = get_best_pytorch_device()\n\n    # CUDA backend\n    if device.type == \"cuda\":\n        print(\"Clearing CUDA memory cache...\")\n        torch.cuda.empty_cache()\n\n    # Call model_management's soft_empty_cache for ComfyUI\n    print(\"Calling soft_empty_cache from ComfyUI model_management...\")\n    model_management.soft_empty_cache()\n\n    # Make the /free API call to ensure models are unloaded and memory is freed\n    try:\n        print(f\"Calling /free API at {api_url} to unload models and free memory...\")\n        response = requests.post(\n            f\"{api_url}/free\",  # Use the user-configured API URL\n            json={\"unload_models\": True, \"free_memory\": True},\n        )\n        if response.status_code == 200:\n            print(\"/free API call successful.\")\n        else:\n            print(f\"/free API call failed with status code {response.status_code}.\")\n    except Exception as e:\n        print(f\"Failed to call /free API: {e}\")\n</code></pre>"},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.ModelUnloader.unload_model","title":"<code>unload_model(trigger, api_url, **kwargs)</code>","text":"<p>Unloads models, clears backend-specific memory caches, and calls the /free API to release memory.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>The API URL where the /free endpoint can be accessed.</p> required <code>kwargs</code> <p>Optional arguments to specify which model to unload.</p> <code>{}</code> Source code in <code>src/comfydv/model_unload.py</code> <pre><code>def unload_model(self, trigger, api_url: str, **kwargs):\n    \"\"\"\n    Unloads models, clears backend-specific memory caches, and calls the /free API to release memory.\n\n    Args:\n        api_url (str): The API URL where the /free endpoint can be accessed.\n        kwargs: Optional arguments to specify which model to unload.\n    \"\"\"\n    # Unload models via ComfyUI model management\n    print(\"Attempting to unload models...\")\n    model_to_unload = kwargs.get(\"model\")\n    print(f\"Unloading {model_to_unload}\") if model_to_unload else None\n    loaded_models = model_management.current_loaded_models\n    [\n        pprint(\n            {\n                \"model\": m.model,\n                \"device\": m.device,\n                \"weights_loaded\": m.weights_loaded,\n                \"currently_used\": m.currently_used,\n                \"real_model\": str(m.real_model)[:100],\n            },\n            max_depth=1,\n            max_length=5,\n        )\n        for m in loaded_models\n    ]\n\n    if model_to_unload:\n        for m in loaded_models:\n            if m.model == model_to_unload:\n                print(f\"Unloading model: {m.model}\")\n                m.model_unload()\n    else:\n        print(\"No specific model provided, unloading all models.\")\n        for m in loaded_models:\n            m.model_unload()\n\n    # Clear CUDA/MPS/CPU memory and call /free API\n    self.clear_memory(api_url)\n\n    # Call soft_empty_cache to clear ComfyUI's internal model cache\n    print(\"Calling soft_empty_cache from ComfyUI model_management.\")\n    model_management.soft_empty_cache()\n\n    return (trigger,)\n</code></pre>"},{"location":"reference/comfydv/model_unload/#comfydv.model_unload.get_best_pytorch_device","title":"<code>get_best_pytorch_device(device_type=None, device_number=0)</code>","text":"<p>Determines the best available PyTorch device, using CUDA, MPS, or CPU.</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>Optional[DEVICE_TYPE]</code> <p>Manually specify the device type.</p> <code>None</code> <code>device_number</code> <code>int</code> <p>The device number to select.</p> <code>0</code> <p>Returns:</p> Type Description <code>device</code> <p>torch.device: The best available device for PyTorch operations.</p> Source code in <code>src/comfydv/model_unload.py</code> <pre><code>def get_best_pytorch_device(\n    device_type: Optional[DEVICE_TYPE] = None, device_number: int = 0\n) -&gt; torch.device:\n    \"\"\"\n    Determines the best available PyTorch device, using CUDA, MPS, or CPU.\n\n    Args:\n        device_type (Optional[DEVICE_TYPE]): Manually specify the device type.\n        device_number (int): The device number to select.\n\n    Returns:\n        torch.device: The best available device for PyTorch operations.\n    \"\"\"\n    dev: torch.device = None\n\n    # Override if device_type is specified\n    if device_type:\n        dev = torch.device(\n            f\"{device_type.value}{':' &amp; device_number if device_number else ''}\"\n        )\n\n    # Detect CUDA devices\n    elif torch.cuda.is_available():\n        print(f\"CUDA detected. Using device {device_number}.\")\n        dev = torch.device(f\"{DEVICE_TYPE.CUDA.value}:{device_number}\")\n\n    # Detect MPS backend (Apple Silicon)\n    elif torch.backends.mps.is_available():\n        dev = torch.device(DEVICE_TYPE.MPS.value)\n        print(\"MPS device detected. Setting environment for MPS fallback.\")\n        os.environ[\"PYTORCH_ENABLE_MPS_FALLBACK\"] = \"1\"\n\n    # Default to CPU\n    else:\n        dev = torch.device(DEVICE_TYPE.CPU.value)\n        print(\"No GPU devices found, using CPU.\")\n\n    print(f\"Set device to: {dev}\")\n    return dev\n</code></pre>"},{"location":"reference/comfydv/random_choice/","title":"random_choice","text":""},{"location":"reference/comfydv/random_choice/#comfydv.random_choice.RandomChoice","title":"<code>RandomChoice</code>","text":"Source code in <code>src/comfydv/random_choice.py</code> <pre><code>class RandomChoice:\n    def __init__(self):\n        pass\n\n    @classmethod\n    def INPUT_TYPES(s):\n        \"\"\"\n        Return a dictionary which contains config for all input fields.\n        Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\".\n        Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node.\n        The type can be a list for selection.\n\n        Returns: `dict`:\n            - Key input_fields_group (`string`): Can be either required, hidden or optional. A node class must have property `required`\n            - Value input_fields (`dict`): Contains input fields config:\n                * Key field_name (`string`): Name of a entry-point method's argument\n                * Value field_config (`tuple`):\n                    + First value is a string indicate the type of field or a list for selection.\n                    + Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".\n        \"\"\"\n        return {\n            \"required\": {\"input1\": (any_type,)},\n            \"optional\": {\n                \"seed\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 0xFFFFFFFFFFFFFFFF})\n            },\n        }\n\n    RETURN_TYPES = (any_type,)\n    RETURN_NAMES = (\"choice\",)\n\n    FUNCTION = \"random_choice\"\n\n    OUTPUT_NODE = False\n\n    CATEGORY = \"dv/utils\"\n\n    \"\"\"\n        The node will always be re executed if any of the inputs change but\n        this method can be used to force the node to execute again even when the inputs don't change.\n        You can make this node return a number or a string. This value will be compared to the one returned the last time the node was\n        executed, if it is different the node will be executed again.\n        This method is used in the core repo for the LoadImage node where they return the image hash as a string, if the image hash\n        changes between executions the LoadImage node is executed again.\n    \"\"\"\n\n    @classmethod\n    def IS_CHANGED(s, **kwargs):\n        return s.random_choice(s, **kwargs)\n\n    def random_choice(self, **kwargs):\n        (\n            random.seed(kwargs.get(\"seed\"))\n            if kwargs.get(\"seed\")\n            else random.seed(random.randrange(sys.maxsize))\n        )\n        print(colored(\"\\nRandom Choice\", \"white\", \"on_red\"))\n        input = [i for i in kwargs.items() if i[0] != \"seed\"]\n        print(colored(\"Got these inputs:\", \"green\"))\n        pprint(input)\n        try:\n            choice = random.choice(input)[1]\n            print(colored(f\"Chose: {choice}\\n\", \"green\"))\n            return (choice,)\n        except Exception as e:\n            raise e\n</code></pre>"},{"location":"reference/comfydv/random_choice/#comfydv.random_choice.RandomChoice.CATEGORY","title":"<code>CATEGORY = 'dv/utils'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The node will always be re executed if any of the inputs change but this method can be used to force the node to execute again even when the inputs don't change. You can make this node return a number or a string. This value will be compared to the one returned the last time the node was executed, if it is different the node will be executed again. This method is used in the core repo for the LoadImage node where they return the image hash as a string, if the image hash changes between executions the LoadImage node is executed again.</p>"},{"location":"reference/comfydv/random_choice/#comfydv.random_choice.RandomChoice.INPUT_TYPES","title":"<code>INPUT_TYPES(s)</code>  <code>classmethod</code>","text":"<p>Return a dictionary which contains config for all input fields. Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\". Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node. The type can be a list for selection.</p> <p>`dict`:</p> Type Description <ul> <li>Key input_fields_group (<code>string</code>): Can be either required, hidden or optional. A node class must have property <code>required</code></li> </ul> <ul> <li>Value input_fields (<code>dict</code>): Contains input fields config:</li> <li>Key field_name (<code>string</code>): Name of a entry-point method's argument</li> <li>Value field_config (<code>tuple</code>):<ul> <li>First value is a string indicate the type of field or a list for selection.</li> <li>Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".</li> </ul> </li> </ul> Source code in <code>src/comfydv/random_choice.py</code> <pre><code>@classmethod\ndef INPUT_TYPES(s):\n    \"\"\"\n    Return a dictionary which contains config for all input fields.\n    Some types (string): \"MODEL\", \"VAE\", \"CLIP\", \"CONDITIONING\", \"LATENT\", \"IMAGE\", \"INT\", \"STRING\", \"FLOAT\".\n    Input types \"INT\", \"STRING\" or \"FLOAT\" are special values for fields on the node.\n    The type can be a list for selection.\n\n    Returns: `dict`:\n        - Key input_fields_group (`string`): Can be either required, hidden or optional. A node class must have property `required`\n        - Value input_fields (`dict`): Contains input fields config:\n            * Key field_name (`string`): Name of a entry-point method's argument\n            * Value field_config (`tuple`):\n                + First value is a string indicate the type of field or a list for selection.\n                + Secound value is a config for type \"INT\", \"STRING\" or \"FLOAT\".\n    \"\"\"\n    return {\n        \"required\": {\"input1\": (any_type,)},\n        \"optional\": {\n            \"seed\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 0xFFFFFFFFFFFFFFFF})\n        },\n    }\n</code></pre>"},{"location":"reference/comfydv/utils/","title":"utils","text":""},{"location":"reference/comfydv/utils/#comfydv.utils.AnyType","title":"<code>AnyType</code>","text":"<p>               Bases: <code>str</code></p> <p>A special class that is always equal in not equal comparisons. Credit to pythongosssss and rgthree.</p> Source code in <code>src/comfydv/utils.py</code> <pre><code>class AnyType(str):\n    \"\"\"A special class that is always equal in not equal comparisons. Credit to pythongosssss and rgthree.\"\"\"\n\n    def __ne__(self, __value: object) -&gt; bool:\n        return False\n</code></pre>"}]}